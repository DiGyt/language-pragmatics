{"remainingRequest":"/home/dirk/WebstormProjects/chat_experiment/language-pragmatics/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/dirk/WebstormProjects/chat_experiment/language-pragmatics/node_modules/magpie-base/src/components/stimuli/Rsvp.vue?vue&type=script&lang=js&","dependencies":[{"path":"/home/dirk/WebstormProjects/chat_experiment/language-pragmatics/node_modules/magpie-base/src/components/stimuli/Rsvp.vue","mtime":499162500000},{"path":"/home/dirk/WebstormProjects/chat_experiment/language-pragmatics/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/dirk/WebstormProjects/chat_experiment/language-pragmatics/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmltcG9ydCBXYWl0IGZyb20gJy4uL2hlbHBlcnMvV2FpdCc7CgpleHBvcnQgZGVmYXVsdCB7CiAgbmFtZTogJ1JzdnAnLAogIGNvbXBvbmVudHM6IHsgV2FpdCB9LAogIHByb3BzOiB7CiAgICAvKioKICAgICAqIFRoZSBjaHVua3MKICAgICAqLwogICAgY2h1bmtzOiB7CiAgICAgIHR5cGU6IEFycmF5LAogICAgICByZXF1aXJlZDogdHJ1ZQogICAgfSwKICAgIC8qKgogICAgICogSW50ZXJ2YWwgYmV0d2VlbiBjaHVua3MgaW4gbWlsaXNlY29uZHMKICAgICAqLwogICAgaW50ZXJ2YWw6IHsKICAgICAgdHlwZTogTnVtYmVyLAogICAgICBkZWZhdWx0OiAzMDAKICAgIH0KICB9LAogIGRhdGEoKSB7CiAgICByZXR1cm4gewogICAgICBwb3NpdGlvbjogMAogICAgfTsKICB9LAogIG1ldGhvZHM6IHsKICAgIG5leHRDaHVuaygpIHsKICAgICAgdGhpcy5wb3NpdGlvbisrOwogICAgICBpZiAodGhpcy5wb3NpdGlvbiA+PSB0aGlzLmNodW5rcy5sZW5ndGgpIHsKICAgICAgICB0aGlzLiRlbWl0KCdlbmQnKTsKICAgICAgfQogICAgfQogIH0KfTsK"},{"version":3,"sources":["Rsvp.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"Rsvp.vue","sourceRoot":"node_modules/magpie-base/src/components/stimuli","sourcesContent":["<docs>\nThis component allows you to display textual or other content in a rapid serial manner, commonly known as Rapid Serial Visual Presentation (RSVP).\n\n### Text\n```vue\n<Experiment>\n  <template #screens>\n    <Screen>\n      <template #0=\"{nextSlide}\">\n        <button @click=\"nextSlide\">Start</button>\n      </template>\n      <template #1=\"{nextSlide}\">\n        <Rsvp :chunks=\"'I wonder if you can read this, as it is a rapid serial visual presentation of a long text.'.split(' ')\"\n              @end=\"nextSlide\" />\n      </template>\n      <template #2>\n        That's what I thought.\n      </template>\n    </Screen>\n  </template>\n</Experiment>\n```\n\n### Images\nThe Rsvp component allows you to define the presentation of the chunks you provide. E.g. we could also use this component to display images.\n```vue\n<Experiment>\n  <template #screens>\n    <Screen>\n      <template #0=\"{nextSlide}\">\n        <button @click=\"nextSlide\">Start</button>\n      </template>\n      <template #1=\"{nextSlide}\">\n        <Rsvp :chunks=\"[\n            'public/images/rsvp1.jpg',\n            'public/images/rsvp2.jpg',\n            'public/images/rsvp3.jpg',\n            'public/images/rsvp4.jpg',\n            ]\" @end=\"nextSlide\">\n          <template #presentation=\"{chunk}\">\n            <img :src=\"chunk\" />\n          </template>\n        </Rsvp>\n      </template>\n      <template #2>\n        Done.\n      </template>\n    </Screen>\n  </template>\n</Experiment>\n```\n\n\n</docs>\n\n<template>\n  <div>\n    <slot name=\"presentation\" :chunk=\"chunks[position]\">\n      <p>{{ chunks[position] }}</p>\n    </slot>\n    <Wait\n      v-if=\"position < chunks.length\"\n      :key=\"position\"\n      :time=\"interval\"\n      @done=\"nextChunk\"\n    />\n  </div>\n</template>\n\n<script>\nimport Wait from '../helpers/Wait';\n\nexport default {\n  name: 'Rsvp',\n  components: { Wait },\n  props: {\n    /**\n     * The chunks\n     */\n    chunks: {\n      type: Array,\n      required: true\n    },\n    /**\n     * Interval between chunks in miliseconds\n     */\n    interval: {\n      type: Number,\n      default: 300\n    }\n  },\n  data() {\n    return {\n      position: 0\n    };\n  },\n  methods: {\n    nextChunk() {\n      this.position++;\n      if (this.position >= this.chunks.length) {\n        this.$emit('end');\n      }\n    }\n  }\n};\n</script>\n"]}]}